<!DOCTYPE html>
<!-- saved from url=(0072)https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/unified-theory-gc/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CS 6120: A Unified Theory of Garbage Collection</title>

  <link href="./A Unified Theory of Garbage Collection_files/main.css" rel="stylesheet">
  <link rel="alternate" type="application/rss+xml" href="https://www.cs.cornell.edu/courses/cs6120/2019fa/rss.xml">
  <link rel="icon" href="https://www.cs.cornell.edu/courses/cs6120/2019fa/img/favicon.ico">
  <link rel="apple-touch-icon-precomposed" href="https://www.cs.cornell.edu/courses/cs6120/2019fa/img/favicon152.png">
  
<meta name="twitter:card" content="summary">
<meta property="og:type" content="article">
<meta property="og:title" content="A Unified Theory of Garbage Collection">
<meta property="og:description" content="Summary
Tracing and reference counting are normally viewed as the two main, completely different approaches to garbage collection. However, in A Unified Theory of Garbage Collection, Bacon et al. showed tracing and reference counting to be duals of one another, and
that all garbage collectors are various types of hybrids of tracing and reference counting. Intuitively, tracing is tracking the live objects while reference counting is tracking dead objects.
Background
Broadly speaking, garbage collection (GC) is a form of automatic memory management. The garbage collector attempts to free the memory blocks occupied by objects that are no longer in use by the program. It relieves programmers from the burden of explicitly freeing allocated memory. Moreover, it also serves as part of the security strategy of languages like Java: in the Java virtual machine programmers are unable to accidentally (or purposely) crash the machine by incorrectly freeing memory. The opposite is manual memory management, which is available in C/C++. This gives the maximum freedom for programmers and avoids the potential overhead that affects program performance.
The task garbage collection needs to solve is identifying the objects not accessible by the program in the reference graph. It then frees the unreachable objects and rearranges the memory sometimes to reduce heap fragmentation. 
The most traditional approaches are tracing and reference counting:">

<!-- KaTeX -->
<link rel="stylesheet" href="./A Unified Theory of Garbage Collection_files/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer="" src="./A Unified Theory of Garbage Collection_files/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer="" src="./A Unified Theory of Garbage Collection_files/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body, { delimiters: [ {left: &#39;$$&#39;, right: &#39;$$&#39;, display: true}, {left: &#39;\\[&#39;, right: &#39;\\]&#39;, display: true}, {left: &#39;$&#39;, right: &#39;$&#39;, display: false} ] });"></script>


</head>
<body>
  <header>
    <nav>
      <h1>
          <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa">CS 6120</a>
      </h1>
      
      
      
      
      
      <p><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/schedule/">
        Schedule
      </a></p>
      
      
      
      <p><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/syllabus/">
        Syllabus
      </a></p>
      
      
      
      <p><a href="https://cs6120-2019fa.slack.com/">Slack</a></p>
      
      <p><a href="https://github.com/sampsyo/cs6120">GitHub</a></p>
      
      
      <p><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/">
        Blog
      </a></p>
      
      <p><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/project/">
        Projects
      </a></p>
    </nav>
  </header>
  <main>
    


<h1>
    <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/">
    The CS 6120 Course Blog
    </a>
</h1>
<article>
  <h1>A Unified Theory of Garbage Collection</h1>
  <p class="details">
    
      <span class="author"> by
      
        <a href="https://github.com/anastos">Mark Anastos</a>,
      
        Qian Huang
      
      <span>
    
    <time datetime="2019-11-08">
      November  8, 2019
    </time>
  </span></span></p>
  <h2 id="summary">Summary</h2>
<p>Tracing and reference counting are normally viewed as the two main, completely different approaches to garbage collection. However, in <a href="https://dl.acm.org/citation.cfm?id=1028982">A Unified Theory of Garbage Collection</a>, Bacon et al. showed tracing and reference counting to be duals of one another, and
that all garbage collectors are various types of hybrids of tracing and reference counting. Intuitively, tracing is tracking the live objects while reference counting is tracking dead objects.</p>
<h2 id="background">Background</h2>
<p>Broadly speaking, garbage collection (GC) is a form of automatic memory management. The garbage collector attempts to free the memory blocks occupied by objects that are no longer in use by the program. It relieves programmers from the burden of explicitly freeing allocated memory. Moreover, it also serves as part of the security strategy of languages like Java: in the Java virtual machine programmers are unable to accidentally (or purposely) crash the machine by incorrectly freeing memory. The opposite is manual memory management, which is available in C/C++. This gives the maximum freedom for programmers and avoids the potential overhead that affects program performance.</p>
<p>The task garbage collection needs to solve is identifying the objects not accessible by the program in the reference graph. It then frees the unreachable objects and rearranges the memory sometimes to reduce heap fragmentation. </p>
<p>The most traditional approaches are tracing and reference counting:</p>
<ul>
<li>Tracing: Recursively mark reachability by starting from a set of root memory
blocks that are in use (e.g., pointed to by global variables or local
variables currently in stack frames).</li>
<li>Reference Counting: Count the number of pointers pointing to one particular
object by bookkeeping it every time a pointer is created or modified. It frees
the object when the counter decreases to zero.</li>
</ul>
<p>These two approaches have a lot differences:</p>
<img src="./A Unified Theory of Garbage Collection_files/diff.png" style="width: 100%">
<p>Although tracing naturally solves the reachability problem accurately, it requires traversing over a static graph and therefore suspending the whole program. On the other hand, reference counting is done incrementally along with each pointer assignment. However, it brings unnecessary overhead when the pointers are changed often and it does not collect cycles of garbage. Thus people proposed more complicated algorithms based on different hypotheses, such as deferred reference counting, generational garbage collection, etc.</p>
<h2 id="tracing-reference-counting-are-duals">Tracing &amp; Reference Counting are Duals</h2>
<p>On the high level, tracing is tracking "matter" -- all reachable objects, while reference counting is tracking "anti-matter" -- all unreachable objects. Their connection is further revealed when we align them by removing certain "optimizations". We can consider a version of tracing that computes the number of incoming edges from roots or live objects instead of a single bit; and a version of reference counting that postpones the decrements to be processed in batches. If the graph contains no cycles, both methods would converge to tagging the same value for each object. Tracing achieves this by setting this value to zero and increases it recursively, while reference counting starts from an upper bound and decrements it recursively. </p>
<p>To formalize this connection, we define the value they converge to mathematically then align their algorithmic structures.</p>
<h3 id="mathematical-model">Mathematical Model</h3>
<p>In order to analyze and compare different garbage collection strategies, the
paper presents a mathematical model of the memory management problem that
garbage collection is trying to solve. Objects in memory and the pointers that
they contain are modeled as the nodes and edges of a graph, respectively. The
set of objects is denoted as <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>, and the multiset of pointers between objects
is <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span></span></span>. An object should not be freed if it will be used in the future. A
conservative approximation of this, without any program analysis, is that an
object might be used in the future if there exists a path of pointers to the
object which originates from the stack or from a register. We call the starting
points of such paths (i.e., all objects to which there is a direct pointer on
the stack or in a register) the roots of the graph, which make up the multiset
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>.</p>
<p>Using these definitions, we can formulate the reference counts of objects
(denoted <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> for <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>) as a fixed point of the following equation:</p>
<p><span><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mo fence="false">∣</mo><mo stretchy="false">[</mo><mi>v</mi><mo>:</mo><mi>v</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">]</mo><mo fence="false">∣</mo><mo>+</mo><mo fence="false">∣</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mo>∧</mo><mi>ρ</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn><mo stretchy="false">]</mo><mo fence="false">∣</mo></mrow><annotation encoding="application/x-tex"> \rho(v) = \big|[v : v \in R]\big| +
\big|[(w, v) : (w, v) \in E \land \rho(w) &gt; 0]\big| </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21799em; vertical-align: -0.35001em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86798em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.26698em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.86798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21799em; vertical-align: -0.35001em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">]</span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86798em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.26698em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.86798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.21799em; vertical-align: -0.35001em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86798em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.26698em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.86798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21799em; vertical-align: -0.35001em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.86798em;"><span class="" style="top: -2.25599em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.26698em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span><span class="" style="top: -2.86798em;"><span class="pstrut" style="height: 2.606em;"></span><span class="delimsizinginner delim-size1"><span class="">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35001em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Here we recursively define the reference count of an object <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> to be the number
of root pointers to <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> plus the number of pointers to <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> from objects which
themselves have non-zero reference counts. Any object whose reference count is
zero according a fixed point of <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span></span> can be freed, as there is no way for the
program to reference it in the future.</p>
<p>However, it is important to note that there could be multiple fixed points to
this equation, namely in the presence of cyclic garbage. If object <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span> points to
object <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span>, and vice versa, but neither is a root and neither is pointed to from
elsewhere, then either <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ρ</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\rho(a) = \rho(b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> or <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ρ</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\rho(a) = \rho(b) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> is a
valid solution to the fixed-point equation. Ideally, a garbage collection
algorithm will find the least fixed point of <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span></span>, meaning that it will
consider all cyclic garbage as able to be freed. A tracing collector does this,
whereas a reference counting collector does not detect any cyclic garbage, and
thus finds the greatest fixed point.</p>
<h3 id="alignments-of-algorithmic-structures">Alignments of Algorithmic Structures</h3>
<p>As modeled in the paper, a tracing garbage collector fundamentally works by
performing a traversal on the memory graph, starting from the root objects in
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>. Every time it reaches an object, it increments its reference count. And,
when it reaches an object for the first time, it traverses the pointers from
that object. In order to complete the traversal, the algorithm maintains a work
list, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span></span></span></span></span>, of objects that it needs to visit. This traversal recomputes all
reference counts completely each time it runs. When it terminates, every live
object will have a positive reference count, and every dead object will have a
reference count of zero.</p>
<p>This formulation of the algorithm differs in a few ways from a standard tracing
collector. For example, there is no need in a real tracing collector to keep
track of the full reference count of each object; it is sufficient to keep just
a single mark bit which determines whether the reference count is non-zero. A
tracing collector might also employ other optimizations, such as <a href="http://www-inst.eecs.berkeley.edu/~cs61bl/r//cur/graphs/garbage-collection-no-fringe.html">pointer
reversal</a>, to improve its run time or memory usage. However, these
optimizations do not significantly change the core ideas of the algorithm.</p>
<p>Reference counting collection differs from tracing collection in that the
reference counts persist over time and are computed iteratively. The paper
models reference counting collectors to keep a work list, just as tracing
collectors do. Every time a pointer is stored somewhere, its reference count is
immediately incremented. Every time a pointer is overwritten or erased, it is
added to the work list. Then, when the collection algorithm runs, the work list
is iterated through, decrementing the reference count of each object in the
list, and, if this causes the reference count to become zero, adding any objects
that are pointed to by that object to the work list. When this algorithm
terminates, every live object will still have a positive reference count, and
the reference counts of dead objects could be zero (depending on if they are
part of a garbage cycle).</p>
<p>Real implementations of reference counting collection will typically not have a
work list. Instead, they will immediately decrement the reference count whenever
a pointer is overwritten, and, if the reference count becomes zero, recursively
decrement the reference count of anything that is pointed to by that object. The
algorithm is presented in this work-list format in order to more clearly
represent its relationship to tracing garbage collection. Formulated in this
way, if we look at the code for the central work-list algorithms for each type
of garbage collector, we can see striking similarities between them:</p>
<table><thead><tr><th align="center"><img src="./A Unified Theory of Garbage Collection_files/tracing-wl.png" style="width:100%"></th><th align="center"><img src="./A Unified Theory of Garbage Collection_files/rc-wl.png" style="width:100%"></th></tr></thead><tbody>
<tr><td align="center">Graph traversal algorithm for tracing</td><td align="center">Work-list algorithm for RC</td></tr>
</tbody></table>
<p>The only differences between the two are that tracing increments the reference
counts of objects on the worklist whereas RC decrements them, and that tracing
checks if <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\rho(w) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> for when to add the objects that <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span> points to whereas
RC checks if <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\rho(w) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>. The two garbage collection strategies also differ in
how <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span></span></span></span></span> is initialized. For tracing, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span></span></span></span></span> initially contains all of the roots of
the graph, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span></span></span>. For reference counting, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span></span></span></span></span> starts with all of the objects that
have had a pointer to them erased since the last time the algorithm ran. By
viewing the two strategies through this formulation, we can see that they are
opposites of each other in many ways:</p>
<img src="./A Unified Theory of Garbage Collection_files/diff-v2.png" style="width:100%">
<p>As discussed in the mathematical model part, reference counting requires an extra pass to collect cycles. This is generally be done by two strategies: backup tracing, which traces (part of) the heap occasionally, and trial deletion, which attempts to decrease <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span> by trial-and-error guided by heuristics. However, notice that there is also a counterpart for that in tracing: the sweeping phase. In addition, while tracing converges to the fixed point value starting from the lower bound of all reference counts at 0, reference counting starts from the upper bound, which contains all incoming pointers that existed at the time of the previous collection. </p>
<h2 id="hybrids">Hybrids</h2>
<p>The authors further show that all realistic garbage collectors are in fact hybrids of tracing and reference counting. In general, we can categorize collectors to unified heap collectors, split heap collectors, and multi-heap collectors. Then different garbage collectors can be seen as performing tracing or reference counting when tracking references within each region and across regions.</p>
<h3 id="unified-heap-collectors-deferred-reference-counting-partial-tracing">Unified Heap collectors: Deferred Reference Counting &amp; Partial Tracing</h3>
<table><thead><tr><th align="center"><img src="./A Unified Theory of Garbage Collection_files/deferred.png" alt="Snow" style="width:100%"></th><th align="center"><img src="./A Unified Theory of Garbage Collection_files/partial.png" alt="Snow" style="width:100%"></th></tr></thead><tbody>
<tr><td align="center">Deferred Reference Counting</td><td align="center">Partial Tracing</td></tr>
</tbody></table>
<p>Rather than doing reference counting completely, Deferred Reference Counting defers updating the reference counts of objects pointed to directly by roots until batch processing. This is based on the observation that pointers from roots are likely to change very often as they are directly used in the program. Notice that we can view this as tracing from roots to their targets and reference counting for the intra-heap pointers: All the assignments that lead to intra-heap pointer changes would be tracked by reference counting as normal. When we suspend the program, we trace the roots for one level, which compensates for the delay.</p>
<p>Reversely, we could design Partial Tracing, which uses reference counting for edges from roots to heaps while tracing the intra-heap pointers. However, this combines the worst properties of both tracing and reference counting: it suffers from the high mutation cost from the fast-changing of root pointers while still need to spend a long time to trace the heap. This design failure demonstrates that although tracing and reference counting are duals, they are not equally easy to solve under different cases. </p>
<h3 id="split-heap-and-multi-heap-collectors">Split-Heap and Multi-Heap Collectors</h3>
<p>The most common split-heap collector architecture is generational collectors. Generational collectors are based on the empirical observation that most objects are short lived, as shown in the left figure below. Here the Y axis shows the number of bytes allocated and the X axis shows the number of bytes allocated over time.</p>
<table><thead><tr><th align="center"><img src="./A Unified Theory of Garbage Collection_files/ObjectLifetime.gif" alt="" style="width:100%"></th><th align="center"><img src="./A Unified Theory of Garbage Collection_files/gen.png" alt="" style="width:100%"></th></tr></thead><tbody>
<tr><td align="center"><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Most objects are short lived</a></td><td align="center">Generational collectors</td></tr>
</tbody></table>
<p>So a generational collector isolates out a nursery space from the remaining mature space. Most of the time it only collects garbage from this nursery space and moves the remaining alive objects to mature space (minor collections). Once in a while it performs a garbage collection across the whole heap to clean the mature space (major collections). An example of generational collectors is available in <a href="https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/">this blog</a>.</p>
<p>This process can also be seen as a combination of tracing and reference counting as shown by (a) in the right figure: Reference counting is performed to track edges from mature space to nursery space. Tracing is performed within nursery space during minor collections. And finally a full tracing is performed during major collections.</p>
<p>We can then explore different combinations of tracing and reference counting within each space. However, notice that reference counting is always used for the edges from mature to nursery space in order to avoid visiting all objects in the mature space. In fact, the authors claim that any algorithm
that collects some subset of objects independently is fundamentally making use of reference counting. </p>
<p>This conclusion is further used for multi-heap collectors, which split heaps into multiple regions and collect each region individually. They can be treated asymmetrically (as in generational collectors) or symmetrically. One of the basic extensions from generational collectors is the Train algorithm. The Train algorithm extended the mature space to multiple regions of different "generations", where only one region is collected at a time. This is mainly for reducing the pause time for collecting the mature space. Specifically, it divides the Mature Object Space (MOS) to cars of fixed size, which are chained to form trains. Each time, the current youngest car will be collected, until the whole first train is collected. We assume that then this process moves on to the next train, but then it is unclear to us why we need several trains instead of one train with all cars?</p>
<h2 id="cost-analysis">Cost Analysis</h2>
<p>The paper also presents an abstract mathematical representation for analyzing
and comparing the space and time costs of different garbage collectors. In order
to represent the memory that a garbage collector requires, they define
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span></span></span>, for any garbage collector <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span>, to be the space overhead of <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span></span></span></span></span> in
units of the size of a single object. For several of the garbage collectors
discussed in the paper, they give equations or approximations of <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span></span></span></span></span>. As an
example, for a tracing collector, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>≃</mo><mfrac><mi mathvariant="script">M</mi><mi>ω</mi></mfrac><mo>+</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\sigma(T) \simeq \frac{\mathcal{M}}{\omega} +
\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">ω</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathcal mtight">M</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right: 0.02778em;">D</span></span></span></span></span></span>, where <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">M</mi></mrow><annotation encoding="application/x-tex">\mathcal{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathcal">M</span></span></span></span></span></span> is the capacity of memory in units of the
object size, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">ω</span></span></span></span></span> is the size of an object in bits, and <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right: 0.02778em;">D</span></span></span></span></span></span> is the
space cost of the traversal stack, proportional to the traversal depth. This
model represents a version&nbsp;of tracing collection without pointer reversal, and
hence includes the traversal stack. If pointer reversal were considered,
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right: 0.02778em;">D</span></span></span></span></span></span> could be removed from the space equation, but this would also
increase the time cost of the collector due to the additional graph traversal
required.</p>
<p>They define <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span></span></span> to be the time overhead of a garbage collector. For each
collector, they define <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span></span></span></span></span> in terms of a linear function of various
properties of the program, omitting the constant factors that could vary between
implementations. In general, they define the overhead as <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau(X) =
\phi(X)\kappa(X) + \mu(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.1132em;">τ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">μ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="mclose">)</span></span></span></span></span>, where <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span></span> is the frequency at which collection
occurs, <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">κ</span></span></span></span></span> is the run time of a single garbage collection execution, and
<span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span></span> is the overhead for mutation in the program (e.g., incrementing and
decrementing reference counts). Each of these terms depends on the type of
garbage collection, as well as the program that the collection is running on,
and is defined more specifically in the paper for several collection strategies.</p>
<p>These equations for the time and space costs of various collectors in terms of
parameters of the workload enable the comparison of different collectors to
determine how well-suited they are for certain mutator programs and constraints.
While not giving the exact formulations for these properties, which would be
difficult to do in general, the abstracted equations give an idea of how the
space and time of a collector vary with their parameters, and thus what the
important constraints of each are.</p>
<h2 id="conclusion">Conclusion</h2>
<p>By better understanding the shared structure and duality of tracing and
reference counting collectors, we can consider the design of a high-performance
garbage collector as a balance between the two base strategies. And, by modeling
the time and space costs of different collectors, we can formally analyze the
trade-offs between different collection strategies for a specific workload or in
general. The paper suggests that the design of a garbage collector involves
three major decisions: how to partition memory, how to traverse memory, and what
space-time trade-offs should be used. The heap can be divided into multiple
segments, as with generational and multi-heap collectors, or can be collected
uniformly. Each component of the heap, as well as the roots of the graph, can
then be traversed and collected through either tracing or reference counting.
And within the implementation of the two strategies there are other space-time
trade-offs to consider as well, such as whether to employ pointer reversal.</p>
<p>In general, this paper provides a beautiful perspective that unifies garbage collectors to a spectrum between tracing and reference counting. It affects how garbage collectors are viewed afterward and the development of other unified theories in systems. </p>
<p>However, there are several aspects ignored in this paper too. Note that in this paper, the authors are only concerned with identifying unreachable objects correctly with high performance in terms of speed and space usage. This assumes that malloc can always do a perfect job to avoid memory fragmentation. But some garbage collectors are also designed to compact objects (i.e., copying garbage collectors).</p>
<p>In addition, this formulation also ignores reachable memory leaks fundamentally. Although the memory manager can recover unreachable memory, it cannot free memory that is still reachable and therefore potentially still useful. Modern memory managers therefore provide techniques for programmers to semantically mark memory with varying levels of usefulness, which correspond to varying levels of reachability.</p>
<p>Finally, there are also other methods that do automatic memory management partially in/before compile time: <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10802/pdf/LIPIcs-ECOOP-2019-10.pdf">abstract garbage collection</a>, which soundly over-approximates the behaviour of a concrete
interpreter and <a href="https://dl.acm.org/citation.cfm?id=1993493">self-collecting mutators</a>, which imposes extra invariants to help garbage collection.</p>

  <footer>
    
    <p>Mark Anastos is an undergraduate senior studying Computer Science and
Electrical &amp; Computer Engineering. Qian Huang is an undergraduate junior
studying Computer Science and Mathematics.</p>

    
    <p>This is the course blog for <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/">CS 6120</a>, the PhD-level compilers course in the computer science department at Cornell.
You can subscribe to <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/">posts on the blog</a> with <a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/rss.xml">RSS</a>.</p>

  </footer>
</article>

  </main>
  <footer>
    <p><a href="https://www.cornell.edu/">Cornell University</a>
    —
    <a href="https://www.cs.cornell.edu/">Department of Computer Science</a></p>
  </footer>


</body></html>